正常我们去访问0地址是会程序崩溃的

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ%E6%88%AA%E5%9B%BE20211120211116.png)

我们可以看到能够打印0地址，但是对0地址读写是失败的

正常CPU给的一个物理页大小为4kb，而操作系统给的物理页为64kb，也就是16个CPU给的物理页大小

程序从0地址开始会被操作系统预留一个大小64kb的页，这64kb都是被用来当作无效内存使用的

在内存中低2GB和高2GB中间也有个64kb大小的物理页，作用:防止用户层直接使用内核层

其实对于0地址访问失败是因为没有物理页，我们可以手工挂个物理页，也就是把物理页挂载到PTE[0]

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ%E6%88%AA%E5%9B%BE20211120214301.png)

我们可以发现PTE[0]是0，也就是没有物理页

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ%E6%88%AA%E5%9B%BE20211120214629.png)

我们申请一个变量，尝试把变量的物理页挂到PTE[0],这样就可以进行操作了

0x10B8000拆成10-10-12
          
          0000 0000 0100  index:4
          0000 1011 1000  index:B8
          0000 0000 0000  index:0
          
![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ%E6%88%AA%E5%9B%BE20211120224650.png)

现在已经找到了我们变量的物理页，把它挂到PTE[0]

PTE[0]为afb70000

        !ed afb70000 2ffb1847//虽然物理页为2ffb1000，但是我们修改时还是得加上属性
        
![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ%E6%88%AA%E5%9B%BE20211120224927.png)

这个时候我们已经给0地址挂上物理页了，在回到操作系统中去访问一下0地址试试,读取0地址成功

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ%E6%88%AA%E5%9B%BE20211120225004.png)
