CPU：
---

8位：4004 8008 8080

16位：8086

32位：80386

段寄存器分类：
---
CS 代码段

SS 堆栈段

DS 数据段

ES 拓展段

FS TEB或KPCR

GS

32位的内存空间：0-FFFFFFFF

应用层：2G、0x0-0x7FFFFFFF

内核层：2G、0x80000000-0xFFFFFFFF

内核层2G是共享内存，但应用层2G是独立的，虚拟的，具备隔离，页限制/页保护

段选择子
---

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ%E6%88%AA%E5%9B%BE20211004220220.png)

**首先段是具有属性的**

CS 代码段，可读可执行，不可以写

DS 数据段，可读也可写，不可执行

做个实验

		#include<windows.h>

		int val = 0x10;
		int main(){
			_asm{
				mov ax,cs;
				mov ds,ax;
				mov ebx,0x11;
				mov dword ptr[val] , ebx;

			}
			return 0;
		}
    
这串代码运行时会报错

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ%E6%88%AA%E5%9B%BE20211004220514.png)

这是因为我们把cs段赋给了ds段，所以在最后赋值的时候，ebx会去篡改cs段中的内容，但是cs段是不可以写的，所以发生报错


**探究base和limit**

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ%E6%88%AA%E5%9B%BE20211014224231.png)

当我们向ds:[0]，写入数据就会触发异常

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ%E6%88%AA%E5%9B%BE20211014224258.png)

当我们向fs:[0]写入数据就没有问题，这实际上与段的base有关

我们发现除了ds，其他的段base都是从0开始

![](https://raw.githubusercontent.com/Whitebird0/tuchuang/main/QQ%E6%88%AA%E5%9B%BE20211014224631.png)
